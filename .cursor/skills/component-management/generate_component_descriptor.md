name: generate-component-descriptor
description: |
  PORTABLE SKILL - Copy this file to any component project to generate a standardized 
  component description. The output can then be added to the Architectural Reasoning Partner.
version: 1.0.0
portable: true

---

# COMPONENT DESCRIPTOR GENERATOR

## Overview

This skill analyzes the current component/project and generates a standardized description that can be registered with the Architectural Reasoning Partner. Copy this file to any component project you want to document.

## How to Use

1. **Copy this file** to the target component's `.cursor/skills/` directory
2. **Run the command:** `/generate-component-descriptor`
3. **Copy the output** to the Architectural Reasoning Partner project
4. **Run:** `/add-component` in the Partner project to register it

---

## COMMAND: /generate-component-descriptor

When invoked, this skill will:
1. Analyze the codebase structure
2. Detect technologies used
3. Identify APIs, events, and data models
4. Generate a standardized descriptor

### Analysis Steps

#### Step 1: Detect Project Type & Technologies

**Search for technology indicators:**

| Indicator | Technology |
|-----------|-----------|
| `pom.xml`, `build.gradle` | Java (Maven/Gradle) |
| `package.json` + Angular deps | Angular |
| `package.json` + React deps | React |
| `package.json` + Express/Nest | Node.js Backend |
| `requirements.txt`, `pyproject.toml` | Python |
| `go.mod` | Go |
| `Cargo.toml` | Rust |
| `*.csproj` | .NET |

**For mixed-technology components, detect ALL technologies present.**

#### Step 2: Identify Component Boundaries

**Search for:**
- API definitions (controllers, routes, OpenAPI specs)
- Event publishers/consumers
- Data models and entities
- Service interfaces
- Database schemas/migrations

#### Step 3: Map Business Capabilities

**Analyze to determine:**
- What business domain does this component serve?
- What entities does it own?
- What operations does it expose?
- What integrations does it have?

---

## OUTPUT FORMAT

Generate output in this exact format (YAML inside markdown code block):

```yaml
# COMPONENT DESCRIPTOR
# Generated by: generate-component-descriptor skill
# Generated at: [timestamp]

component:
  name: "[component-name]"
  description: "[1-2 sentence description of what this component does]"
  
  # Business domain this component belongs to
  domain: "[Order Management | Customer & Identity | Transaction & Financial | Frontend Experience | Integration & Events | Analytics & Reporting | Inventory & Catalog | Other]"
  
  # Component type
  type: "[backend-service | frontend-app | shared-library | integration-service | monorepo]"

# Guardians - people responsible for this component
# Main guardians: 1 or more required (primary owners/maintainers)
# Secondary guardians: 0 or more optional (backup contacts, contributors)
guardians:
  main:
    - name: "[Full Name]"
      email: "[email@company.com]"
      role: "[Tech Lead | Senior Developer | Architect | etc.]"
    # Add more main guardians as needed (at least 1 required)
  secondary:
    - name: "[Full Name]"
      email: "[email@company.com]"
      role: "[Developer | Contributor | etc.]"
    # Secondary guardians are optional

# Technologies used in this component
technologies:
  primary: "[main technology, e.g., Java/Spring, Angular, React, Node.js]"
  secondary: 
    - "[additional tech 1]"
    - "[additional tech 2]"
  # For mixed-tech components, list all major technologies
  stack_details:
    backend: "[Java/Spring | Node.js | Python | Go | None]"
    frontend: "[Angular | React | Vue | None]"
    database: "[PostgreSQL | MySQL | MongoDB | None]"
    messaging: "[Kafka | RabbitMQ | Redis | None]"

# What this component owns (authoritative source)
owns:
  entities:
    - name: "[Entity name]"
      description: "[Brief description]"
      storage: "[table name or collection]"
    # Add more entities...
  
  business_rules:
    - "[Description of business rule 1]"
    - "[Description of business rule 2]"

# APIs exposed by this component
apis:
  rest:
    - method: "[GET|POST|PUT|DELETE]"
      path: "/api/[path]"
      description: "[What this endpoint does]"
    # Add more endpoints...
  
  graphql: "[yes|no]"
  grpc: "[yes|no]"

# Events this component works with
events:
  publishes:
    - name: "[EventName]"
      topic: "[topic/queue name]"
      description: "[When this event is published]"
    # Add more events...
  
  consumes:
    - name: "[EventName]"
      topic: "[topic/queue name]"
      description: "[What happens when this event is received]"
    # Add more events...

# Dependencies on other components
dependencies:
  calls:
    - component: "[other-component-name]"
      type: "[sync-api | async-event]"
      purpose: "[Why this dependency exists]"
    # Add more dependencies...
  
  called_by:
    - component: "[other-component-name]"
      type: "[sync-api | async-event]"
      purpose: "[Why other components call this]"

# Trigger phrases that indicate this component should be involved
trigger_phrases:
  - "[phrase 1 that suggests this component]"
  - "[phrase 2 that suggests this component]"
  - "[phrase 3 that suggests this component]"

# Additional notes for the architectural reasoning system
notes:
  - "[Any special considerations]"
  - "[Known patterns or anti-patterns]"
```

---

## EXAMPLE OUTPUT

```yaml
# COMPONENT DESCRIPTOR
# Generated by: generate-component-descriptor skill
# Generated at: 2024-01-15T10:30:00Z

component:
  name: "transaction-monitoring-service"
  description: "Monitors financial transactions for suspicious activity and high-value thresholds, generating alerts for the risk team."
  domain: "Transaction & Financial"
  type: "backend-service"

guardians:
  main:
    - name: "Sarah Chen"
      email: "sarah.chen@company.com"
      role: "Tech Lead"
    - name: "Marcus Johnson"
      email: "marcus.johnson@company.com"
      role: "Senior Developer"
  secondary:
    - name: "Alex Rivera"
      email: "alex.rivera@company.com"
      role: "Developer"

technologies:
  primary: "Java/Spring Boot"
  secondary:
    - "Kafka"
    - "PostgreSQL"
  stack_details:
    backend: "Java/Spring"
    frontend: "None"
    database: "PostgreSQL"
    messaging: "Kafka"

owns:
  entities:
    - name: "TransactionAlert"
      description: "Represents a flagged transaction requiring attention"
      storage: "transaction_alerts"
    - name: "MonitoringRule"
      description: "Configurable rules for transaction monitoring"
      storage: "monitoring_rules"
  
  business_rules:
    - "Transactions over $10,000 trigger high-value alert"
    - "Multiple transactions from same source in 5 minutes trigger velocity alert"
    - "International transactions from new customers require additional review"

apis:
  rest:
    - method: "GET"
      path: "/api/alerts"
      description: "List all alerts with filtering and pagination"
    - method: "GET"
      path: "/api/alerts/high-value"
      description: "List only high-value transaction alerts"
    - method: "POST"
      path: "/api/alerts/{id}/acknowledge"
      description: "Mark an alert as acknowledged by risk team"
    - method: "GET"
      path: "/api/rules"
      description: "List monitoring rules"
  
  graphql: "no"
  grpc: "no"

events:
  publishes:
    - name: "HighValueTransactionAlertEvent"
      topic: "transactions.alerts.high-value"
      description: "Published when a transaction exceeds the high-value threshold"
    - name: "SuspiciousActivityDetectedEvent"
      topic: "transactions.alerts.suspicious"
      description: "Published when suspicious pattern is detected"
  
  consumes:
    - name: "TransactionCreatedEvent"
      topic: "transactions.created"
      description: "Triggers monitoring analysis for new transactions"

dependencies:
  calls:
    - component: "customer-service"
      type: "sync-api"
      purpose: "Fetch customer risk profile and history"
    - component: "case-management-service"
      type: "sync-api"
      purpose: "Create investigation case for critical alerts"
  
  called_by:
    - component: "merchant-portal"
      type: "sync-api"
      purpose: "Display alerts to merchants"
    - component: "risk-dashboard"
      type: "sync-api"
      purpose: "Display alerts to risk team"

trigger_phrases:
  - "transaction monitoring"
  - "high-value transaction"
  - "suspicious activity"
  - "fraud detection"
  - "transaction alert"
  - "risk analysis"

notes:
  - "Alerting thresholds are configurable per merchant"
  - "Uses Redis for real-time velocity checking"
  - "Integrates with external fraud scoring API"
```

---

## MIXED-TECHNOLOGY COMPONENT EXAMPLE

For a component that contains both backend and frontend:

```yaml
component:
  name: "admin-dashboard"
  description: "Full-stack admin application with Java backend and Angular frontend for managing system configuration and monitoring."
  domain: "Frontend Experience"
  type: "monorepo"

technologies:
  primary: "Angular + Java/Spring"
  secondary:
    - "PostgreSQL"
    - "WebSocket"
  stack_details:
    backend: "Java/Spring"
    frontend: "Angular"
    database: "PostgreSQL"
    messaging: "WebSocket"

# Backend portion
backend:
  path: "backend/"
  apis:
    rest:
      - method: "GET"
        path: "/api/admin/config"
        description: "Get system configuration"
      - method: "PUT"
        path: "/api/admin/config"
        description: "Update system configuration"

# Frontend portion
frontend:
  path: "frontend/"
  framework: "Angular 17"
  pages:
    - name: "ConfigurationPage"
      route: "/admin/config"
      description: "System configuration management"
    - name: "MonitoringDashboard"
      route: "/admin/monitoring"
      description: "Real-time system monitoring"

# ... rest of descriptor
```

---

## AUTOMATION HINTS

When analyzing the codebase, look for:

**Java/Spring:**
- `@RestController`, `@RequestMapping` → API endpoints
- `@Entity`, `@Table` → Data models
- `@KafkaListener`, `@JmsListener` → Event consumers
- `KafkaTemplate`, `JmsTemplate` → Event publishers

**Node.js/Express:**
- `router.get/post/put/delete` → API endpoints
- Mongoose schemas, TypeORM entities → Data models
- `consumer.subscribe` → Event consumers
- `producer.send` → Event publishers

**Angular:**
- `@Component`, `@NgModule` → UI components
- `*.service.ts` → Service layer
- Route definitions → Pages/features
- WebSocket services → Real-time connections

**React:**
- `*.tsx` components → UI components
- Custom hooks → Data fetching patterns
- Router configuration → Pages/features
- Context providers → State management

---

## NEXT STEPS

After generating the descriptor:

1. **Review the output** for accuracy
2. **Copy the YAML block** 
3. **In the Architectural Reasoning Partner project**, run:
   ```
   /add-component
   [paste the YAML]
   ```
4. The Partner will create a rule file for this component
